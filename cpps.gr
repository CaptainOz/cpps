%baseclass-preinclude "Types.h"
%namespace cpps
%stype AbstractSyntaxTree::Node*

%token TypeName
%token Variable
%token StringLiteral
%token NumericLiteral
%token Colon
%token Semicolon
%token Increment   Decrement
%token OpenParen   CloseParen
%token OpenBracket CloseBracket
%token OpenBrace   CloseBrace
%token If          Else

%left   Comma
%right  Throw
%right  Assign
        AssignPlus      AssignMinus     AssignConcat
        AssignMultiply  AssignDivide    AssignModulo
        AssignBitAnd    AssignBitXOr    AssignBitOr
        AssignLeftShift AssignRightShift
%right  TernaryIf
%left   LogicalOr
%left   LogicalAnd
%left   BitwiseOr
%left   BitwiseXOr
%left   BitwiseAnd
%left   Equality    NotEquality
%left   LessThan    LessEqual
        GreaterThan GreaterEqual
%left   LeftShift   RightShift
%left   Minus   Plus        Concat
%left   Divide  Multiply    Modulo
%right  pre_increment   pre_decrement
        unary_minus     unary_plus
        LogicalNot      BitwiseNot
        TypeCast
        Reference
        SizeOf
        New
        Delete
%left   post_increment  post_decrement
        FunctionCall
        Index
        MemberAccess
        TypeNameOperator
%left   ResolveScope

%%

var
    : Variable
        {
            $$ = $1;
        }
    ;

string
    : StringLiteral
        {
            $$ = $1;
        }
    ;

number
    : NumericLiteral
        {
            $$ = $1;
        }
    ;

statement
    : exp_statement
    | complex_statement
        {
            m_currentScope->addStatement( $1 );
            $$ = NULL;
        }
    ;

complex_statement
    : if_statement
    | compound_statement
    | switch_statement
    | loop_statement
    | jump_statement
    | function_definition
    | var_declaration Semicolon
        {
            $$ = $1;
        }
    ;

compound_statement
    : OpenBrace CloseBrace
    | OpenBrace statement_list CloseBrace
    ;

statement_list
    : // empty
    | statement_list statement
    ;

exp_statement
    : Semicolon
    | exp Semicolon
        {
            m_currentScope->addStatement( $1 );
            $$ = NULL;
        }
    ;

if_statement
    : If OpenParen exp CloseParen statement
        {
            $$ = new nodes::IfStatement( $3, $5 );
        }
    ;

switch_statement
    : Switch OpenParen exp CloseParen case_list
        {
            $$ = new nodes::SwitchStatement( $3, $5 );
        }
    ;

case_statement
    : Case exp Colon statement
        {
            $$ = new nodes::CaseStatement( $2, $4 );
        }
    | Default Colon statement
        {
            $$ = new nodes::DefaultCaseStatement( $3 );
        }
    ;

case_list
    : // empty
    | case_list case_statement
    ;

loop_statement
    : While OpenParen exp CloseParen statement
        {
            $$ = new nodes::WhileLoop( $3, $5 );
        }
    | Do statement While OpenParen exp CloseParen Semicolon
        {
            $$ = new nodes::DoWhileLoop( $5, $2 );
        }
    | For OpenParen exp_statement exp_statement CloseParen statement
        {
            $$ = new nodes::ForLoop( $3, $4, NULL, $6 );
        }
    | For OpenParen exp_statement exp_statement exp CloseParen statement
        {
            $$ = new nodes::ForLoop( $3, $4, $5, $7 );
        }
    | Foreach OpenParen exp Comma var CloseParen statement
        {
            $$ = new nodes::ForeachLoop( $3, NULL, $5, $7 );
        }
    | Foreach OpenParen exp Comma var Colon var CloseParen statement
        {
            $$ = new nodes::ForeachLoop( $4, $5, $7, $9 );
        }
    ;

jump_statement
    : Continue Semicolon
        {
            $$ = new nodes::ContinueStatement();
        }
    | Break Semicolon
        {
            $$ = new nodes::BreakStatement();
        }
    | Return Semicolon
        {
            $$ = new nodes::ReturnStatement( NULL );
        }
    | Return exp Semicolon
        {
            $$ = new nodes::ReturnStatement( $2 );
        }
    ;

function_definition
    : declaration OpenParen var_declaration_list CloseParen compound_statement
        {
            $$ = new nodes::FunctionDefinition( $1, $3, $5 );
        }
    ;

var_declaration_list
    : // empty
    | var_declaration
        {
            $$ = new nodes::VariableDeclarationList( $1 );
        }
    | var_declaration_list Comma var_declaration
        {
            dynamic_cast<nodes::VariableDeclarationList*>($1)->addDeclaration( $3 );
            $$ = $1;
        }
    ;

var_declaration
    : var_qualifier_list var_type_specifier Variable
        {
            $$ = new nodes::VariableDeclaration( $2, $3, $1 );
        }
    ;

var_qualifier_list
    : // empty
    | var_qualifier_list var_qualifier
        {
            if( $1 == NULL ){
                $1 = new nodes::VariableQualifierList();
            }
            dynamic_cast<nodes::VariableQualifierList*>($1)->addQualifier( $2 );
            $$ = $1;
        }
    ;

var_qualifier
    : Const
    | Static
    ;

var_type_specifier
    : TypeName
    | Var
    ;

exp
    : var
    | string
    | number
    | function_call
    | type_cast
    | operation
    ;

operation
    : unary_operation
    | binary_operation
    | ternary_operation
    ;

unary_operation
    : unary_minus
    | unary_plus
    | LogicalNot exp
        {
            $$ = new nodes::LogicalNegation( $2 );
        }
    | BitwiseNot exp
        {
            $$ = new nodes::BitwiseNegation( $2 );
        }
    | pre_increment
    | pre_decrement
    | post_increment
    | post_decrement
    ;

unary_minus
    : Minus exp
        {
            $$ = new nodes::Negation( $2 );
        }
    ;

unary_plus
    : Plus exp
        {
            $$ = $2;
        }
    ;

pre_increment
    : Increment exp
        {
            $$ = new nodes::PreIncrement( $2 );
        }
    ;

pre_decrement
    : Decrement exp
        {
            $$ = new nodes::PreDecrement( $2 );
        }
    ;

post_increment
    : exp Increment
        {
            $$ = new nodes::PostIncrement( $2 );
        }
    ;

post_decrement
    : exp Decrement
        {
            $$ = new nodes::PostDecrement( $2 );
        }

binary_operation
    : exp LogicalOr exp
        {
            $$ = new nodes::LogicalOr( $1, $3 );
        }
    | exp LogicalAnd exp
        {
            $$ = new nodes::LogicalAnd( $1, $3 );
        }
    | exp Equality exp
        {
            $$ = new nodes::Equality( $1, $3 );
        }
    | exp NotEquality exp
        {
            $$ = new nodes::NotEquality( $1, $3 );
        }
    | exp GreaterEqual exp
        {
            $$ = new nodes::GreaterEqual( $1, $3 );
        }
    | exp LessEqual exp
        {
            $$ = new nodes::LessEqual( $1, $3 );
        }
    | exp Assign exp
        {
            $$ = new nodes::Assignment( $1, $3 );
        }
    | exp AssignPlus exp
        {
            $$ = new nodes::AssignAddition( $1, $3 );
        }
    | exp AssignMinus exp
        {
            $$ = new nodes::AssignSubtraction( $1, $3 );
        }
    | exp AssignMultiply exp
        {
            $$ = new nodes::AssignMultiplication( $1, $3 );
        }
    | exp AssignDivide exp
        {
            $$ = new nodes::AssignDivision( $1, $3 );
        }
    | exp AssignModulo exp
        {
            $$ = new nodes::AssignModulo( $1, $3 );
        }
    | exp AssignBitAnd exp
        {
            $$ = new nodes::AssignBitAnd( $1, $3 );
        }
    | exp AssignBitXOr exp
        {
            $$ = new nodes::AssignBitXOr( $1, $3 );
        }
    | exp AssignBitOr exp
        {
            $$ = new nodes::AssignBitOr( $1, $3 );
        }
    | exp AssignLeftShift exp
        {
            $$ = new nodes::AssignLeftShift( $1, $3 );
        }
    | exp AssignRightShift exp
        {
            $$ = new nodes::AssignRightShift( $1, $3 );
        }
    | exp RightShift exp
        {
            $$ = new nodes::RightShift( $1, $3 );
        }
    | exp LeftShift exp
        {
            $$ = new nodes::LeftShift( $1, $3 );
        }
    | exp MemberAccess exp
        {
            $$ = new nodes::MemberAccess( $1, $3 );
        }
    | exp GreaterThan exp
        {
            $$ = new nodes::GreaterThan( $1, $3 );
        }
    | exp LessThan exp
        {
            $$ = new nodes::LessThan( $1, $3 );
        }
    | exp Plus exp
        {
            $$ = new nodes::Addition( $1, $3 );
        }
    | exp Minus exp
        {
            $$ = new nodes::Subtraction( $1, $3 );
        }
    | exp Multiply exp
        {
            $$ = new nodes::Multiplication( $1, $3 );
        }
    | exp Divide exp
        {
            $$ = new nodes::Division( $1, $3 );
        }
    | exp Modulo exp
        {
            $$ = new nodes::Modulo( $1, $3 );
        }
    | exp BitwiseAnd exp
        {
            $$ = new nodes::BitwiseAnd( $1, $3 );
        }
    | exp BitwiseXOr exp
        {
            $$ = new nodes::BitwiseXOr( $1, $3 );
        }
    | exp BitwiseOr exp
        {
            $$ = new nodes::BitwiseOr( $1, $3 );
        }
    ;

ternary_operation
    : exp TernaryIf exp Colon exp
        {
            $$ = new nodes::TernaryIf( $1, $3, $5 );
        }
    ;

function_call
    : exp OpenParen parameter_list CloseParen
        {
            $$ = new nodes::FunctionCall( $1, $3 );
        }
    ;

type_cast
    : OpenParen TypeName CloseParen exp
        {
            $$ = new nodes::TypeCast( $2, $4 );
        }
    ;


